scriptencoding utf-8

set nocompatible
set number
set ruler
set hlsearch
set fileencoding=utf-8
set fileencodings=ucs-bom,utf-8,euc-jp,iso-2022-jp,cp932,utf-16,utf-16le
set backspace=indent,eol,start
set nrformats=
set visualbell t_vb=
syntax on

" 長い行は折り返し表示
set wrap

" Indent
set autoindent
set cindent
set expandtab
set tabstop=4
set shiftwidth=4

" Temprary file
set nobackup
set nowritebackup
set noswapfile
set noundofile
" set viminfo=

" 小文字のみで入力の場合 -> 大文字小文字を区別しない
" 大文字混在で入力の場合 -> 大文字小文字を区別する
set ignorecase
set smartcase

" conceal無効
set conceallevel=0

" 自動改行をしない
set textwidth=0
" Kaoriya版MacVimのtextwidth対策
augroup vimrc-textwidth-kaoriya
    autocmd!
    autocmd FileType text setlocal textwidth=0
augroup END

if !has('gui_running')
  set t_Co=256
endif

" yankしたテキストをクリップボードに入れる
" set clipboard+=unnamed

""""""""""""""""""""""""""""""""""""""""
" path
"

" path にパスを追加する
function! s:add_path(path)
    let full_path = escape(expand(a:path), ' ')
    if isdirectory(full_path)
        execute 'set path+=' . full_path
    endif
endfunction

call s:add_path('/usr/local/include')
call s:add_path('~/include')


" $PATH にパスを追加する
function! s:add_PATH(path)
    let full_path = escape(expand(a:path), ' ')
    if isdirectory(full_path)
        let $PATH = full_path . ':' . $PATH
    endif
endfunction

call s:add_PATH('/usr/local/bin')
call s:add_PATH('~/bin')
call s:add_PATH('~/.local/bin')
" call s:add_PATH('~/Library/Haskell/bin')
" call s:add_PATH('~/.cabal/bin')
" ghc-mod from source
" call s:add_PATH('~/src/ghc-mod/dist/build/ghc-mod')
" call s:add_PATH('~/src/ghc-mod/dist/build/ghc-modi')
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" dein.vim設定
"

if &compatible
    set nocompatible
endif

filetype off

" プラグインが実際にインストールされるディレクトリ
let s:dein_dir = expand('~/.cache/dein')
" dein.vim 本体
let s:dein_repo_dir = s:dein_dir . '/repos/github.com/Shougo/dein.vim'

" dein.vim がなければ github から落としてくる
if &runtimepath !~# '/dein.vim'
    if !isdirectory(s:dein_repo_dir)
        execute '!git clone https://github.com/Shougo/dein.vim' s:dein_repo_dir
    endif
    execute 'set runtimepath^=' . fnamemodify(s:dein_repo_dir, ':p')
endif

if dein#load_state(s:dein_dir)
    call dein#begin(s:dein_dir)

    " プラグインリストを収めた TOML ファイル
    let s:toml      = '~/.vim/rc/dein.toml'
    let s:lazy_toml = '~/.vim/rc/dein_lazy.toml'
    call dein#load_toml(s:toml,      {'lazy': 0})
    call dein#load_toml(s:lazy_toml, {'lazy': 1})

    call dein#end()
    call dein#save_state()
endif

" もし、未インストールものものがあったらインストール
if dein#check_install()
    call dein#install()
endif

filetype plugin indent on
""""""""""""""""""""""""""""""""""""""""

" '%'拡張プラグイン
source $VIMRUNTIME/macros/matchit.vim

""""""""""""""""""""""""""""""""""""""""
" filetype追加
"
augroup vimrc-filetypes
    autocmd!
    autocmd BufWinEnter,BufNewFile SConstruct set filetype=python
    autocmd BufWinEnter,BufNewFile SConscript set filetype=python
    autocmd BufWinEnter,BufNewFile *.ps1 set filetype=ps1
    autocmd BufNewFile,BufRead *.pu,*.uml,*.plantuml set filetype=plantuml
augroup END
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" 汎用キーマッピング
"
" 挿入モードでのカーソル移動
inoremap <C-j> <Down>
inoremap <C-k> <Up>
inoremap <C-h> <Left>
inoremap <C-l> <Right>

" 行頭・行末に移動
nnoremap <Space>h 0
vnoremap <Space>h 0
nnoremap <Space>l $
vnoremap <Space>l $

" 画面上の最初の行、最後の行に移動
nnoremap <Space>k H
vnoremap <Space>k H
nnoremap <Space>j L
vnoremap <Space>j L

" "0レジスタから貼付け
nnoremap <Space>p "0p
vnoremap <Space>p "0p

" tagsジャンプの時に複数ある時は一覧表示                                        
nnoremap <C-]> g<C-]> 

" 選択範囲を * で検索
vnoremap * "zy:let @/ = @z<CR>n
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" 汎用コマンド
"
command! CdCurrent lcd %:p:h
command! Rc :e ~/.vimrc
command! Fi :VimFilerCurrentDir -create -explorer
command! Sh :VimShellCreate
command! Hex :%!xxd -g 1
command! HexReverse :%!xxd -r
command! Grep :Unite grep
command! UpdatePlugin :call dein#update()

" :vimgrep xxx ** と同様
" command! -nargs=1 Grep call s:grep_recursive(<f-args>)
" function! s:grep_recursive(pattern)
"     execute 'vimgrep /' . a:pattern . '/j ** | cw'
" endfunction
""""""""""""""""""""""""""""""""""""""""

" ディレクトリ以下の「.vimrc_local」を探し、存在する場合は適用(source)する
augroup vimrc-local
    autocmd!
    autocmd BufNewFile,BufReadPost * call s:vimrc_local(expand('<afile>:p:h'))
    autocmd BufReadPre .vimrc_local set ft=vim
augroup END
function! s:vimrc_local(loc)
    let files = findfile('.vimrc_local', escape(a:loc, ' ') . ';', -1)
    for i in reverse(filter(files, 'filereadable(v:val)'))
        source `=i`
    endfor
endfunction

""""""""""""""""""""""""""""""""""""""""
" neovim only
if has('nvim')
    " exit terminal mode
    tnoremap <Esc> <C-\><C-n>
endif

""""""""""""""""""""""""""""""""""""""""
" neocomplete / deoplete
"
" 起動時に有効化
if has('nvim')
    let g:deoplete#enable_at_startup = 1
else
    let g:neocomplete#enable_at_startup = 1
endif
" inoremap <expr><CR> pumvisible() ? neocomplete#close_popup() : "\<CR>"
" inoremap <expr><Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
" inoremap <expr><S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
" inoremap <expr><Esc> pumvisible() ? neocomplete#cancel_popup() : "\<Esc>"
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" neosnippet
"
imap <C-k> <Plug>(neosnippet_expand_or_jump)
smap <C-k> <Plug>(neosnippet_expand_or_jump)
xmap <C-k> <Plug>(neosnippet_expand_target)
" if has('conceal')
  " set conceallevel=2 concealcursor=i
" endif
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" neocomplete + neosnippet
"
" 補完候補選択時の<CR>の動作
" imap <expr><CR> neosnippet#expandable_or_jumpable() ?
" \ "\<Plug>(neosnippet_expand_or_jump)"
" \: pumvisible() ? neocomplete#close_popup() : "\<CR>"
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" vimfiler
"
let g:vimfiler_as_default_explorer = 1
let g:vimfiler_safe_mode_by_default = 0
let g:vimfiler_ignore_pattern = []
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" vimshell
"
" Use current directory as vimshell prompt.
let g:vimshell_prompt_expr = 'escape(fnamemodify(getcwd(), ":~").">", "\\[]()?! ")." "'
let g:vimshell_prompt_pattern = '^\%(\f\|\\.\)\+> '
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" NERD Commenter
"
let NERDSpaceDelims = 1
nmap <Space>c <Plug>NERDCommenterToggle
vmap <Space>c <Plug>NERDCommenterToggle
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" caw.vim
"
" nmap <Space>c <Plug>(caw:i:toggle)
" vmap <Space>c <Plug>(caw:i:toggle)
""""""""""""""""""""""""""""""""""""""""


""""""""""""""""""""""""""""""""""""""""
" unite
"
let g:unite_enable_start_insert = 1

" Unite history/yank を有効化
let g:unite_source_history_yank_enable = 1

" ファイル選択
function! MyUniteOpen()
    let file_rec = ''
    if has('nvim')
        let file_rec = "file_rec/neovim"
    elseif isdirectory(getcwd()."/.git")
        let file_rec = "file_rec/git"
    else
        let file_rec = "file_rec/async"
    endif
    execute 'Unite' file_rec 'tag' 'outline'

    " for NeoBundle
    " if ! empty(neobundle#get('vimproc'))
        " if isdirectory(getcwd()."/.git")
            " Unite file_rec/git
        " else
            " Unite file_rec/async
        " endif
    " else
          " Unite file_rec
    " endif
endfunction
nnoremap <Space>: :<C-u>Unite command mapping<CR>
nnoremap <Space>o :<C-u>call MyUniteOpen()<CR>
nnoremap <Space>g :<C-u>Unite grep<CR>
nnoremap <Space>t :<C-u>Unite tag<CR>
" nnoremap <Space>l :<C-u>Unite outline<CR>
nnoremap <Space>b :<C-u>Unite buffer<CR>
nnoremap <Space>r :<C-u>Unite register<CR>
nnoremap <Space>m :<C-u>Unite file_mru<CR>
" nnoremap <Space>y :<C-u>Unite history/yank<CR>

command! Uopen :call MyUniteOpen()
command! Ugrep :Unite grep
command! Uoutline :Unite outline
command! Utag :Unite tag
command! Ubuffer :Unite buffer
command! Uregister :Unite register
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" unite grep
"
if executable('ag')
    " grepにag(The Silver Searcher) を使う
    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts =
                \ '-i --vimgrep --hidden --ignore ' .
                \ '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
    let g:unite_source_grep_recursive_opt = ''
endif
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" vim-altr
"
nmap <Space>a <Plug>(altr-forward)
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" syntastic
"
" if ! empty(neobundle#get("syntastic"))
    " set statusline+=%#warningmsg#
    " set statusline+=%{SyntasticStatuslineFlag()}
    " set statusline+=%*
    " let g:syntastic_always_populate_loc_list = 1
    " let g:syntastic_auto_loc_list = 1
    " let g:syntastic_check_on_open = 0
    " let g:syntastic_check_on_wq = 0
" endif
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" vim-quickrun
"
" command! Run QuickRun
" command! Open QuickRun open

" g:quickrun_configに設定を追加する
function! s:put_quickrun_config(type, config)
    if !exists("g:quickrun_config")
        let g:quickrun_config = {}
    endif
    let g:quickrun_config[a:type] = a:config
endfunction

" <C-c> で実行を強制終了させる
" quickrun.vim が実行していない場合には <C-c> を呼び出す
nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" vim-watchdogs
"
let g:watchdogs_check_BufWritePost_enable = 1
let g:watchdogs_check_CursorHold_enable = 1
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" lightline.vim
"
let g:lightline = {
            \ 'colorscheme': 'solarized'
            \ }
""""""""""""""""""""""""""""""""""""""""


""""""""""""""""""""""""""""""""""""""""
" wmgraphviz
"
let g:WMGraphviz_output = 'png'
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" C/C++
"

let g:cpp_class_scope_highlight = 1
let g:cpp_experimental_template_highlight = 1

if executable("/usr/local/bin/clang")
    let g:marching_clang_command = "/usr/local/bin/clang"
elseif executable("/usr/bin/clang")
    let g:marching_clang_command = "/usr/bin/clang"
elseif executable("/bin/clang")
    let g:marching_clang_command = "/bin/clang"
endif

let g:marching_enable_neocomplete = 1
if !exists('g:neocomplete#force_omni_input_patterns')
    let g:neocomplete#force_omni_input_patterns = {}
endif
let g:neocomplete#force_omni_input_patterns.cpp =
            \ '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'
set updatetime=200

" インクルードパス一覧
let g:vimrc_include_paths = []
function! g:VimrcAddIncludePath(path) abort
    let full_path = escape(expand(a:path), ' ')

    " pathに追加
    call s:add_path(full_path)

    let found = 0
    for i in g:vimrc_include_paths
        if i == full_path
            let found = 1
        endif
    endfor
    if ! found
        call add(g:vimrc_include_paths, full_path)

        " -Iオプションを作成し、watchdogs_checkerのコマンド引数に追加
        let cmdopt = ''
        for i in g:vimrc_include_paths
            let cmdopt = cmdopt . '-I' . i . ' '
        endfor
        call s:put_quickrun_config("watchdogs_checker/clang",   {"cmdopt" : cmdopt})
        call s:put_quickrun_config("watchdogs_checker/clang++", {"cmdopt" : cmdopt})
        call s:put_quickrun_config("watchdogs_checker/gcc",     {"cmdopt" : cmdopt})
        call s:put_quickrun_config("watchdogs_checker/g++",     {"cmdopt" : cmdopt})
        call watchdogs#setup(g:quickrun_config)
    endif
endfunction

function! s:c_cpp() abort
    setlocal matchpairs+=<:>

    " カレントディレクトリ以下の 'include' ディレクトリを再帰的に探索し、
    " インクルードパスとして追加する (depth=5)
    let include_dirs = finddir('include', './**5', -1)
    let include_search_option = ''
    for include_dir in include_dirs
        call g:VimrcAddIncludePath(getcwd() . '/' . include_dir)
    endfor
endfunction

augroup vimrc-c-cpp
    autocmd!
    autocmd FileType c,cpp call s:c_cpp()
augroup END

""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" Haskell
" 

" vim2hs
let g:haskell_conceal = 0

function! s:haskell() abort
    setlocal omnifunc=necoghc#omnifunc
    " nnoremap <C-c> :<C-u>GhcModCheck<CR>
    nnoremap <C-i> :<C-u>GhcModInfo<CR>
    nnoremap <C-t> :<C-u>GhcModType<CR>
    nnoremap <C-g> :<C-u>GhcModTypeClear<CR>
    command! Hoogle :Unite hoogle
    command! HaskellImport :Unite haskellimport

    " cabal run / cabal build をQuickRunから呼び出す
    " command! CabalBuild :QuickRun cabal/build
    " command! CabalRun :QuickRun cabal/run
    " call s:put_quickrun_config("cabal/build", {
                " \       "exec" : "%c %o",
                " \       "command" : "cabal",
                " \       "cmdopt" : "build",
                " \       "outputter" : "error:buffer:quickfix",
                " \       "runner" : "vimproc",
                " \})
    " call s:put_quickrun_config("cabal/run", {
                " \       "exec" : "%c %o",
                " \       "command" : "cabal",
                " \       "cmdopt" : "run",
                " \       "outputter" : "error:buffer:quickfix",
                " \       "runner" : "vimproc",
                " \})

    " Haskell syntax checker
    " call s:put_quickrun_config("haskell/watchdogs_checker", {
                " \   "type"
                " \       : executable("ghc-mod")     ? "watchdogs_checker/ghc-mod"
                " \       : executable("hlint")       ? "watchdogs_checker/hlint"
                " \       : executable("hdevtools")   ? "watchdogs_checker/hdevtools"
                " \       : ""
                " \   })
    " call watchdogs#setup(g:quickrun_config)

    " call s:make_to_cabal_build()
    call s:make_to_stack_build()

    " haskellmode-vim
    " compiler ghc
    " let g:haddock_browser = '/Applications/Safari.app'
endfunction

" :make で呼び出すコマンドを cabal build に設定する
function! s:make_to_cabal_build()
    if glob("*.cabal") != ''
        setlocal makeprg=cabal\ build
    endif
endfunction

" :make で呼び出すコマンドを stack build に設定する
function! s:make_to_stack_build()
    if glob("stack.yaml") != ''
        setlocal makeprg=stack\ build
    endif
endfunction

augroup vimrc-haskell
    autocmd!
    autocmd FileType haskell call s:haskell()
augroup END
""""""""""""""""""""""""""""""""""""""""


""""""""""""""""""""""""""""""""""""""""
" Python
"
" jediでの補完時に補完候補が選択されてしまう対策
augroup vimrc-python
    autocmd!
    autocmd FileType python setlocal omnifunc=jedi#completions
augroup END
"let g:jedi#popup_select_first=0    " 効かないらしい
let g:jedi#completions_enabled = 0
let g:jedi#auto_vim_configuration = 0
if !exists('g:neocomplete#force_omni_input_patterns')
    let g:neocomplete#force_omni_input_patterns = {}
endif
let g:neocomplete#force_omni_input_patterns.python = '\%([^. \t]\.\|^\s*@\|^\s*from\s.\+import \|^\s*from \|^\s*import \)\w*'
""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""
" blockdiag
call s:put_quickrun_config('blockdiag', {
            \ 'command'     : 'blockdiag',
            \ 'cmdopt'      : '--antialias',
            \ 'runner'      : 'vimproc',
            \ })
augroup blockdiag
    autocmd!
    autocmd BufWinEnter,BufNewFile *.diag set filetype=blockdiag
    autocmd BufWritePost *.diag QuickRun
augroup end
""""""""""""""""""""""""""""""""""""""""
